<script src="https://code.jquery.com/jquery-3.7.1.min.js"
    integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@^4"></script>
<!-- <script src="stats.js"></script> -->

<!-- 
    TODO:
    - Links to .prof, .stats, .prof.svg, .eventlog.html
 -->
<html>
<title>Advent of Code Profiling</title>

</html>

<body>
    <div>
        <!-- <canvas id="chart-..."></canvas> -->
        
    </div>
    <div id="statusTooltip" class="customTooltip"></div>

    <script>
    const getOrCreateTooltip = (chart) => {
        let tooltipEl = chart.canvas.parentNode.querySelector('div');

        if (!tooltipEl) {
            tooltipEl = document.createElement('div');
            tooltipEl.style.background = 'rgba(0, 0, 0, 0.7)';
            tooltipEl.style.borderRadius = '3px';
            tooltipEl.style.color = 'white';
            tooltipEl.style.opacity = 1;
            tooltipEl.style.pointerEvents = 'none';
            tooltipEl.style.position = 'absolute';
            tooltipEl.style.transform = 'translate(-50%, 0)';
            tooltipEl.style.transition = 'all .1s ease';

            const table = document.createElement('table');
            table.style.margin = '0px';

            tooltipEl.appendChild(table);
            chart.canvas.parentNode.appendChild(tooltipEl);
        }

        return tooltipEl;
        };

        const externalTooltipHandler = (context) => {
        // Tooltip Element
        const {chart, tooltip} = context;
        const tooltipEl = getOrCreateTooltip(chart);

        // Hide if no tooltip
        if (tooltip.opacity === 0) {
            tooltipEl.style.opacity = 0;
            return;
        }

        // Set Text
        if (tooltip.body) {
            const titleLines = tooltip.title || [];
            const bodyLines = tooltip.body.map(b => b.lines);

            const tableHead = document.createElement('thead');

            titleLines.forEach(title => {
            const tr = document.createElement('tr');
            tr.style.borderWidth = 0;

            const th = document.createElement('th');
            th.style.borderWidth = 0;
            const text = document.createTextNode(title);

            th.appendChild(text);
            tr.appendChild(th);
            tableHead.appendChild(tr);
            });

            const tableBody = document.createElement('tbody');
            bodyLines.forEach((body, i) => {
            const colors = tooltip.labelColors[i];

            const span = document.createElement('span');
            span.style.background = colors.backgroundColor;
            span.style.borderColor = colors.borderColor;
            span.style.borderWidth = '2px';
            span.style.marginRight = '10px';
            span.style.height = '10px';
            span.style.width = '10px';
            span.style.display = 'inline-block';

            const tr = document.createElement('tr');
            tr.style.backgroundColor = 'inherit';
            tr.style.borderWidth = 0;

            const td = document.createElement('td');
            td.style.borderWidth = 0;

            const text = document.createTextNode(body);

            td.appendChild(span);
            td.appendChild(text);
            tr.appendChild(td);
            tableBody.appendChild(tr);
            });

            const tableRoot = tooltipEl.querySelector('table');

            // Remove old children
            while (tableRoot.firstChild) {
            tableRoot.firstChild.remove();
            }

            // Add new children
            tableRoot.appendChild(tableHead);
            tableRoot.appendChild(tableBody);

            // Add link
            const link = document.createElement('a');   //'<a href="www.google.com">Click Here</a>');
            const linkText = document.createTextNode("Click Here");
            link.appendChild(linkText);
            link.title = "my title text";
            link.href = "http://example.com";
            tableRoot.appendChild(link);
        }

        const {offsetLeft: positionX, offsetTop: positionY} = chart.canvas;

        // Display, position, and set styles for font
        tooltipEl.style.opacity = 1;
        tooltipEl.style.left = positionX + tooltip.caretX + 'px';
        tooltipEl.style.top = positionY + tooltip.caretY + 'px';
        tooltipEl.style.font = tooltip.options.bodyFont.string;
        tooltipEl.style.padding = tooltip.options.padding + 'px ' + tooltip.options.padding + 'px';
        };
    </script>

    <script src='./stats.js'></script>
    <script>
        let getMinMaxBy = function (f, data) {
            const xs = data.map(f);
            return [Math.min(...xs), Math.max(...xs)];
        }
        let [yearLo, yearHi] = getMinMaxBy((r) => r.year, data);
        let [totalTimeSecsLo, totalTimeSecsHi] = getMinMaxBy((r) => r.total_time_secs, data);
        let [totalAllocBytesLo, totalAllocBytesHi] = getMinMaxBy((r) => r.total_alloc_bytes, data);

        var rows = {};
        for (var year = yearLo; year <= yearHi; year++) {
            rows[year] = {};
        }
        for (i in data) {
            var y = parseInt(data[i].year);
            var d = parseInt(data[i].day);
            rows[y][d] = data[i];
        }

        function mkLabel(row) {
            return "day " + row.day;
        }

        let size = function (bytes) {
            if (bytes === 0) {
                return "0.00 B";
            }

            let e = Math.floor(Math.log(bytes) / Math.log(1024));
            return (bytes / Math.pow(1024, e)).toFixed(2) +
                ' ' + ' KMGTP'.charAt(e) + 'B';
        }

        var days = Array.from({ length: 25 }, (x, i) => i + 1);
        var labels = days.map((i) => 'day ' + i);

        for (var year = yearHi; year >= yearLo; year--) {
            var total_time_secs = [];
            var total_alloc_bytes = [];
            var dates = [];
            // var labels = [];
            var proj = [];

            for (var day = 1; day <= 25; day++) {
                dates.push(year + '-12-' + day);
                proj.push("aoc" + year + '-' + day);
                var d = rows[year][day];
                if (d === undefined) {
                    total_time_secs.push(null);
                    total_alloc_bytes.push(null);
                    // labels.push(day + '-' + '???');
                } else {
                    total_time_secs.push(d.total_time_secs);
                    total_alloc_bytes.push(d.total_alloc_bytes);
                    // labels.push(day + '-' + d.name);
                }
            }

            const divid = 'chart-' + year;  // FIXME: (Ab)used in onClick!
            const $div = $(`<div style='margin-bottom: 50px;'><canvas id='${divid}'></canvas></div>`).appendTo('body');

            const skippedArea = {
                id: 'skippedArea',
                beforeDatasetsDraw(chart, args, pluginOptions) {
                    const { ctx, data, chartArea: {left, right, top, bottom, width, height}, scales: {x, y} } = chart;
                    const tickWidth = width / x.max - 1;

                    ctx.save();

                    for (var i = 0; i < data.datasets[0].data.length; ) {
                        const p1 = data.datasets[0].data[i];
                        var j = i + 1;

                        if (p1 !== null) {
                            i = j;
                            continue;
                        }
                        while (j < data.datasets[0].data.length && data.datasets[0].data[j] === null) {
                            j++;
                        }
                        const p2 = data.datasets[0].data[j];
                        ctx.fillStyle = 'rgba(0,0,0,0.1)';
                        ctx.fillRect(x.getPixelForValue(i)-tickWidth/2, top, x.getPixelForValue(j)-x.getPixelForValue(i), height);
                        ctx.restore();
                        i = j;
                    }
                }
            }

            Chart.register(skippedArea);
            const ctx = document.getElementById(divid);

            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: dates,
                    datasets: [{
                        label: 'total_time_secs',
                        data: total_time_secs,
                        yAxisID: 'y',
                        spanGaps: true,
                    },
                    {
                        label: 'total_alloc_bytes',
                        data: total_alloc_bytes,
                        yAxisID: 'y1',
                        spanGaps: true,
                    }]
                },
                options: {
                    events: ['click', 'touchstart', 'touchmove', 'mousemove', 'mouseout'],
                    plugins: {
                        title: {
                            display: true,
                            text: year,
                        },
                        tooltip: {
                            // enabled: false,
                            position: 'nearest',
                            // external: externalTooltipHandler
                            // events: ['click'],
                            callbacks: {
                                title: function(ctx) {
                                    const tooltipItem = ctx[0];
                                    const chart = tooltipItem.chart;
                                    const year = chart.canvas.id.slice(6);
                                    const day = "" + (tooltipItem.dataIndex + 1);
                                    const entry = rows[year][day];
                                    console.log(entry);
                                    return `day ${day}: ${entry.name}`
                                },
                            },
                        },
                        // tooltip: {
                            // callbacks: {
                            //     label: function(context) {
                            //         let label = context.dataset.label || '';
                            //         if (label == 'total_alloc_bytes') {
                            //             label += ': ' + context.formattedValue + " (" + size(context.raw) + ")";
                            //         } else if (label == 'total_time_secs') {
                            //             label += ': ' + context.formattedValue + " s";
                            //         } else if (label) {
                            //             label += ': ' + context.formattedValue;
                            //         }
                            //         return label;
                            //     }
                            // }
                        // },
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    elements: {
                        bar: {
                            borderWidth: 2,
                        }
                    },
                    responsive: true,
                    scaleShowValues: true,
                    scales: {
                        x: {
                            // type: 'time',
                            ticks: {
                                autoSkip: false,
                            },
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            beginAtZero: true,
                            ticks: {
                                callback: function (val, index) {
                                    return val + " s";
                                },
                            },
                            suggestedMin: totalTimeSecsLo,
                            suggestedMax: totalTimeSecsHi,
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            beginAtZero: true,
                            // grid line settings
                            grid: {
                                drawOnChartArea: false, // only want the grid lines for one axis to show up
                            },
                            ticks: {
                                callback: function (val, index) {
                                    return size(val);
                                },
                            },
                            suggestedMin: totalAllocBytesLo,
                            suggestedMax: totalAllocBytesHi,
                        },
                    },
                    onClick: (e) => {
                        const chart = e.chart;
                        const canvasPosition = Chart.helpers.getRelativePosition(e, chart);
                        const dataX = chart.scales.x.getValueForPixel(canvasPosition.x);
                        const day = "" + (dataX + 1);
                        const year = chart.canvas.id.slice(6);
                        const proj = "aoc" + year + "-" + day.padStart(2, '0');
                        const URL = `../${proj}.eventlog.html`;
                        window.open(URL, '_blank');
                        window.open(`../${proj}.prof.svg`, '_blank');
                    },
                },
            });
        }
    </script>
</body>